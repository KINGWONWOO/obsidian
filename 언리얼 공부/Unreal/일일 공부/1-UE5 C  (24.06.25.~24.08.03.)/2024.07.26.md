#### Unreal Engine 5 C++ 개발자  
##### 135강
- TSubclassOf<>는 <>안의 타입을 UClass 형태로 저장하게 도와줌.
- UClass는 블루프린트와 C++ 사이 연동인 리플렉션 시스템 활용에 사용
```C++
    UPROPERTY(EditDefaultsOnly, Category = "Combat")
    class UStaticMeshComponent* ProjectileMesh;
```

- 그럼 TSubclassOf는 왜 필요한가? : SpawnActor의 첫 번째 전달값이 UClass, C++로는 전달하기 어려운 정보들(Static Mesh 설정)을 블루프린트로 전달
- SpawnActor<>(UClass, 위치, 회전)는 UWorld의 함수
```C++
GetWorld()->SpawnActor<AProjectile>(
        ProjectileClass,
        ProjectileSpawnPoint->GetComponentLocation(),
        ProjectileSpawnPoint->GetComponentRotation()
    );
```

##### 137강
- UPrimitiveComponent에는 충돌 관련 함수들이 정의되어 있음(아래 상속된 타입들도 동일)
- Hit Event는 Multicast Delegate로 한 번 발생하면 여러 함수에 전달
- 이때 전달 받는 함수들의 집합을 Invocation list라하고 전달하는 과정을 Broadcast라 함
- Invocation list에 사용자 정의 함수를 추가하는 법
```C++
//.h
UFUNCTION() //UFUNCTION 필수
void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);
//.cpp | BeginPlay()
ProjectileMesh->OnComponentHit.AddDynamic(this, &AProjectile::OnHit);
```
- 이때 함수 입력값은 최대한 자세하기 설정

##### 138강
- UActorComponent : No Transform, No attachment
- USceneComponent : Has Transform, Has Attachment
![[Pasted image 20240726164557.png]]
```C++
//Create a callback
// .h | private:
UFUNCTION()
void DamageTaken(AActor* DamagedActor, float Damage, const UDamageType* DamageType, class AController* Instigator, AAcotr* DamageCauser);
//Bind it to the delegate
// .cpp | BeginPlay()
GetOwner()->OnTakeAnyDamage.AddDynamic(this, &UHealthComponent::DamageTaken);
```

##### 140강
- AGameModeBase : 게임 규칙, 종료 조건(승리, 패배)
- AGameMode : 멀티 플레

##### 141강
![[Pasted image 20240726201817.png]]
- HandleDestruction 구현
```C++
// in Tower
void ATower::HandleDestruction()
{
    Super::HandleDestruction();
    Destroy();
}
//in Tank
//Tank는 User가 사용하는 pawn이므로 Destroy()가 아닌 조작 불가로 만듦
//조작 불가 -> 숨기기/Tick 비활성화/Controller 비활성화
void ATank::HandleDestruction()
{
    Super::HandleDestruction();
    SetActorHiddenInGame(true);
    SetActorTickEnabled(false);
}
```
- ActorDied 구현
```c++
void AToonTanksGameMode::ActorDied(AActor *DeadActor)
{
    if (DeadActor == Tank)
    {
        Tank->HandleDestruction();
        if (Tank->GetTankPlayerController())
        {
            Tank->DisableInput(Tank->GetTankPlayerController());
            Tank->GetTankPlayerController()->bShowMouseCursor = false;
        }
    }
    else if (ATower* DestroyedTower = Cast<ATower>(DeadActor))
    {
        DestroyedTower->HandleDestruction();
    }
}
void AToonTanksGameMode::BeginPlay()
{
    Super::BeginPlay();
    Tank = Cast<ATank>(UGameplayStatics::GetPlayerPawn(this, 0));
}
```
- DamageTaken에서 Actor Died 호출하기
```c++
// GameMode 불러오기
ToonTanksGameMode = Cast<AToonTanksGameMode>(UGameplayStatics::GetGameMode(this));
// 함수 호출
if (Health <= 0.f && ToonTanksGameMode)
	{
		ToonTanksGameMode->ActorDied(DamagedActor);
	}
```
- 변수 이름 변경 시 ***F2*** 사용하면 사용된 모든 코드 위치에서 변경 적용

##### 142강
- 사용자 지정 플레이어 컨트롤러 생성
```C++
void AToonTanksPlayerController::SetPlayerEnabledState(bool bPlayerEnabled)
{
    if (bPlayerEnabled)
	{
	//GetPawn이 안될 시 #include "GameFramework/Pawn.h"
       GetPawn()->EnableInput(this);
    }
    else
    {
        GetPawn()->DisableInput(this);
    }
    bShowMouseCursor = bPlayerEnabled;
}
```

##### 143강
- SetTimer에서 Callback 함수에 입력값이 필요할 시 Delegate를 사용
```C++
if(ToonTanksPlayerController)
    {
        ToonTanksPlayerController->SetPlayerEnabledState(false);
        
        FTimerHandle PlayerEnableTimerHandle;
        FTimerDelegate PlayerEnableTimerDelegate = FTimerDelegate::CreateUObject(
            ToonTanksPlayerController, //부를 함수가 있는 위치
            &AToonTanksPlayerController::SetPlayerEnabledState, //부를 함수
            true // 전달 값
        );
        GetWorldTimerManager().SetTimer(
            PlayerEnableTimerHandle, //타이머 핸들
            PlayerEnableTimerDelegate, //타이머 delegate
            StartDelay, //딜레이 시간
            false // 반복
        );
    }
```