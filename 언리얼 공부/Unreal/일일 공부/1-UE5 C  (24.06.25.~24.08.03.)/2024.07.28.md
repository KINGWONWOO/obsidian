#### Unreal Engine 5 C++ 개발자  
##### 159강
![[Pasted image 20240728141630.png]]
- Controller를 통한 조작 시 DeltaTime을 통한 계산 필수

##### 160강
- 카메라 세부적인 위치 조정은 스프링암의 Offset 조절
![[Pasted image 20240728143007.png]]
- 카메라가 회전을 따라오지 않는다면 detail 체크
 ![[Pasted image 20240728145806.png]]

##### 162강
- 콜리전 오류 발생 시 에디터의 View 모드를 바꿔서 확인 가능
![[Pasted image 20240728150224.png]]
- 이후 해당 Actor 클릭 후 Mesh로 이동해서 Collision 편리

##### 163강
- 애니메이션 블루프린터에서는 Blend 함수를 통해 두 애니메이션간 혼합 가능
- 하지만 이는 이동 애니메이션과는 적합하지 않음
![[Pasted image 20240728160649.png]]


##### 164강
- 애니메이션간 적절한 혼합-변환을 위해서는 Blend Space 기능 활용
- 다음과 같이 설정 가능
![[Pasted image 20240728160623.png]]
![[Pasted image 20240728160635.png]]
##### 165강
- 만들어진 Blend Space는 다음과 같이 Animation Blueprint에서 사용 가능
![[Pasted image 20240728161348.png]]
- 이때 Angle과 Speed와 같이 애니메이션을 결정 짓는 입력값들은 Animation Blueprint Event Graph에서 설정 가능. 다음은 Speed를 설정한 모습
![[Pasted image 20240728161513.png]]

##### 166강
- 각도 계산은 로컬 트랜스폼에서 진행되어야함. 이를 포함한 계산 식
![[Pasted image 20240728164146.png]]

##### 167강
- 발미끄러짐 현상을 최소화하기 위해서는 애니메이션 속도 계산 필요
- 애니메이션을 재생 후 다음 공식 적용
- 속도 = (발 떨어지는 y값 - 발 붙은 y값)/(발 떨어지는 시간 - 발 붙은 시간)으로 계산
- 이후 이 값을 BlendSpace에 적용

##### 169강
- 한 C++ 클래스에서 다른 클래스 Actor Spawn하기
```C++
//.h | public
UPROPERTY(EditDefaultsOnly)
TSubclassOf<AGun> GunClass;

UPROPERTY()
AGun* Gun;
//.cpp | BeginPlay()
Gun = GetWorld()->SpawnActor<AGun>(GunClass);
```

##### 170강
- Socket을 통한 Mesh 부착하기
- 1. Socket 만들기 : Skeletal 설정에 가서 Add Socket 사용용
![[Pasted image 20240728190050.png]]
- 2. 코드를 통해 캐릭터에 해당 Mesh 부착
```C++
//기존에 있던 총 숨기기
GetMesh()->HideBoneByName(TEXT("weapon_r"), EPhysBodyOp::PBO_None);
//Mesh 부착
Gun->AttachToComponent(GetMesh(), FAttachmentTransformRules::KeepRelativeTransform, TEXT("WeaponSocket"));
//이후 처리를 위해 Owner로 설
Gun->SetOwner(this);
```

##### 174강
- LineByTrace를 위해서는 Collision 세팅에서 Trace Channel을 추가 -> 이때 Preset에서 필요한 수정 필요(OverlapAll, BlockAll, IgnoreAll, Invisible---)
- 추가 코드
```C++
FVector End = Location + Rotation.Vector() * MaxRange;
FHitResult Hit;
bool bSuccess = GetWorld()->LineTraceSingleByChannel(Hit, Location, End, ECollisionChannel::ECC_GameTraceChannel1);
if (bSuccess)
{
    DrawDebugPoint(GetWorld(), Hit.Location, 20, FColor::Red, true);
}
```

##### 175강
- 파티클이 반대로 튀는 경우(총을 쏘고 맞추는 위치에서 발생 시) 다음과 같은 코드 활용 가능
```C++
FVector ShotDirection = -Rotation.Vector();
UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ImpactEffect, Hit.Location, ShotDirection.Rotation());
```

##### 176강
- float TakeDamage 함수
 ```C++
float TakeDamage (
float Damage , //데미지량
struct FRadialDamageEvent const& RadialDamageEvent, //데미지의 타입, 설명
class AController* EventInstigator, //데미지 발생시킨 주체
AActor* DamageCauser //데미지 원인(총, 수류탄)
)
```
-  FRadialDamageEvent : 수류탄 같은 데미지
-  FPointDamageEvent : 총 같은 데미지
```C++
FPointDamageEvent(
float InDamage //데미지량
struct FHitResult const& InHitInfo //타격위치 정
FVector const& InShortDirection //사격 방향
TSubclassOf<class UDamageType> InDamageTypeClass
)
```
- 실제 예시 코드
```C++
#include "Engine/DamageEvents.h"

AActor* HitActor = Hit.GetActor();
if (HitActor != nullptr)
{
	FPointDamageEvent DamageEvent(Damage, Hit, ShotDirection, nullptr);
	HitActor->TakeDamage(Damage, DamageEvent, OwnerController, this);
}
```

##### 177강
- 다이나믹 디스패치 : 효율성을 중시하는 C++에 의도적인 비효울성을 강제하는 것
- Virtual 접두사 : C++의 경우 오버라이드가 진행된 클래스 사이에서도 포인터를 통한 함수 호출 시 부모 함수를 부르는 상황 발생. 이를 방지하기 위해 Virtual을 사용 -> 오버라이드 된 함수가 있는가 검사
- Override 접미사 : 일종의 안전장치, 이 함수가 이름이 틀리진 않았는가, Virtual로 선언된 함수를 오버라이드 하고 있는가등을 검사.

##### 178강
- 데미지 받는 것을 처리하기 위해 상위 클래스의 TakeDamage 함수를 Override
```C++
float AShooterCharacter::TakeDamage(float DamageAmount, struct FDamageEvent const &DamageEvent, class AController *EventInstigator, AActor *DamageCauser) 
{
	float DamageToApply = Super::TakeDamage(DamageAmount, DamageEvent, EventInstigator, DamageCauser);
	DamageToApply = FMath::Min(Health, DamageToApply);
	Health -= DamageToApply;
	UE_LOG(LogTemp, Warning, TEXT("Health left %f"), Health);
	return DamageToApply;
}
```

##### 179강
- 애니메이션 블루프린트에서 Blend Poses by Bool을 통해 상황에 맞춘 애니메이션 선택 가능