#### Unreal Engine 5 C++ 개발자  
##### 180강
- C++ 함수를 블루프린트에서 사용하기 위해서는 BlueprintCallable사용, 순수 노드로 사용하기 위해서는 BlueprintPure 사용
- 순수함수 : 실행핀이 없으며 어떠한 변화도 일으키지 않는 함수 -> const 사용
```C++
UFUNCTION(BlueprintPure)
bool IsDead() const;
```

##### 181강
- 사용자 Custom AI Controller 적용법
- AIController 기반 C++ class 생성
- 해당 클래스 기반 블루프린트 생성
- 이후 Character BP의 Detail에서 Pawn\AI Controller Class 설정 변경
- ![[Pasted image 20240802142026.png]]

##### 182강
- AIController 내장 함수에는 Focus를 설정하는 함수가 3개 존재
	- SetFocalPoint(FVector, 우선순위) : 고정된 한 지점을 응시
	- SetFocus(AActor*, 우선순위) : 움직이는 물체를 지속해서 추척 응시
	- ClearFocus(우선순위) : 응시를 해제
- Foucs 인자로는 우선순위를 전달 미리 정의된 우선순위는 다음과 같음.
	- Default = 0
	- Move = 1
	- Gameplay = 2
- Pawn을 가져온 후 SetFocus를 사용하는 코드 예시
```C++
#include "Kismet/GameplayStatics.h"

void AShooterAIController::BeginPlay()
{
    Super::BeginPlay();
    APawn* PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);

    SetFocus(PlayerPawn);
}
```

##### 183강
- AI가 User를 쫓아오게 하기
	1. Nav Mesh를 통해 이동 가능한 구역 설정
	![[Pasted image 20240802144747.png]]
	2. AIController에서 코드 작성
	```C++
	APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);
    MoveToActor(PlayerPawn, 200); //200은 2m 여유를 두고 접근
    //MoveToLocation도 존재
	```

##### 184강
- AI의 시야에 User(혹은 특정 사물)이 있을 경우에만 동작하게 하고 싶을 시 LightOfSightTo 함수 사용
```C++
 if (LineOfSightTo(PlayerPawn))
    {
        SetFocus(PlayerPawn);
        MoveToActor(PlayerPawn, AcceptanceRadius);
    }
 else
    {
        ClearFocus(EAIFocusPriority::Gameplay);
        StopMovement();
    }
```

##### 185강
- 위와 같이 AI의 행동 절차를 코드로 구현해도 되지만, Behavior Tree, BlackBoard를 통해 더욱 쉽게 구현 가능
	- Behavior Tree는 AI의 행동 절차를 구현
	- BlackBorad는 AI의 행동 절차에 필요한 변수를 저장하는 메모리 역할
- 코드를 통한 Behavior Tree 활성화
```C++
//.h
private:
        UPROPERTY(EditAnywhere)
        class UBehaviorTree* AIBehavior;
//.cpp | beginplay()
if (AIBehavior != nullptr)
    {
        RunBehaviorTree(AIBehavior);
    }
```

##### 186강
- C++로 블랙보드 키 설정하기(변수 추가하기)
	1. C++ 코드에 블랙보드 변수 추가
	```C++
	#include "BehaviorTree/BlackboardComponent.h`
		
	APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);
	
	//1번째 인자 : 저장하는 변수명
	//2번째 인자 : 저장값
	GetBlackboardComponent()->SetValueAsVector(TEXT("PlayerLocation"), PlayerPawn->GetActorLocation());
	```
	2. 블랙보드에 해당 변수명과 같은 변수 추가

##### 187강
- BlackBoard에서 설정한 값들을 이용하여 Behavior Tree 구성 가능
![[Pasted image 20240802154941.png]]

##### 188강
- Behavior Tree Selector 노드 : Left to Right로 실행 단, 자식 노드중 하나라도 실행이 완료되면 종료
- Decorator : Sequence노드에 Decorator를 추가해서 Loop나, 참-거짓 등 다양한 효과 추가 가능
![[Pasted image 20240802160118.png]]
- Blackboard Decorator는 특정 변수가 갱신될 때 참을 반환
- 다음은 Tree 예시 구현 : PlayerLocation이 Set-갱신되는 경우(AI가 Player를 발견) Player를 쫓음 그 외에는 Player가 마지막으로 발견된 장소에서 대
![[Pasted image 20240802160334.png]]
- Blackboard Deco의 경우 Observer aborts 설정 가능
	- None : 아무 효과 없음
	- Self : Chase 실행 중 조건이 거짓이 되면 하던 작업을 멈추고 Selector를 재평
	- Lower Priority : Investigate 실행 중 조건이 참이 되면 바로 Chase 실행
	- Both : 참이 되면 Chase, 거짓이 되면 Investigate를 하던 작업을 중지하고 바로 실행
- Player가 시야에 보일 시 BlackBoard 변수들을 초기화하는 코드
```C++
if (LineOfSightTo(PlayerPawn))
    {
        GetBlackboardComponent()->SetValueAsVector(TEXT("PlayerLocation"), PlayerPawn->GetActorLocation());
        GetBlackboardComponent()->SetValueAsVector(TEXT("LastKnownPlayerLocation"), PlayerPawn->GetActorLocation());
    }
    else
    {
        GetBlackboardComponent()->ClearValue(TEXT("PlayerLocation"));
    }
```

##### 189강
- 사용자 Custom Task 만들기
	1. BTTask C++ 클래스 생성
	2. 해당 클래스에서 생성자를 통해 노드 이름 설정
	```C++
	UBTTask_ClearBlackboardValue::UBTTask_ClearBlackboardValue()
	{
	    NodeName = TEXT("Clear Blackboard Value");
	}
	```
	3. BT에서 해당 Task 호출 및 사용

##### 190강
- BTTask Node에 있어서 구현 중요성이 높은 함수들(Parent 코드의 Override들)
	1. ExecuteTask : Node 실행 시 첫 Tick에 실행되는 동작
	2. AbortTask : Node 종료 시 실행되는 동작
	3. TickTask : 첫 Tick 다음 Tick부터 지속적으로 실행되는 동작
	4. OnMessage : Node 종료 시 전달되느 메세지
- ExecuteTask를 통해 Key 삭제를 구현한 코드
```C++
`#include "BehaviorTree/BlackboardComponent.h"`

EBTNodeResult::Type UBTTask_ClearBlackboardValue::ExecuteTask(UBehaviorTreeComponent &OwnerComp, uint8 *NodeMemory)
{
    Super::ExecuteTask(OwnerComp, NodeMemory);

    OwnerComp.GetBlackboardComponent()->ClearValue(GetSelectedBlackboardKey());

    return EBTNodeResult::Succeeded;
}
```
- EBTNodeResult::Type 값으로는 4가지가 존재
	- Succeeded : 성공 처리, 진행
	- Failed : 실패 처리, 진행
	- Aborted : 실패 처리, 진행 불가
	- InProgress : 아직 안끝남


##### 191강
- Task 노드에서 Observe Blackboard Value 활성화 시 Value 값을 지속적으로 업데이
 ![[Pasted image 20240802163641.png]]
 - Pawn의 함수를 사용하는 Task 생성 예시, 이때 호출하는 함수는 Public 이여야함.
 ```C++
#include "AIController.h"
#include "ShooterCharacter.h"
EBTNodeResult::Type UBTTask_Shoot::ExecuteTask(UBehaviorTreeComponent &OwnerComp, uint8 *NodeMemory)
{
    Super::ExecuteTask(OwnerComp, NodeMemory);

    if (OwnerComp.GetAIOwner() == nullptr)
    {
        return EBTNodeResult::Failed;
    }

    AShooterCharacter* Character = Cast<AShooterCharacter>(OwnerComp.GetAIOwner()->GetPawn());

    if (Character == nullptr)
    {
        return EBTNodeResult::Failed;
    }

    Character->Shoot();

    return EBTNodeResult::Succeeded;
}
```

##### 192강
- BT의 Service를 사용하면 AI Controller에서 하던 Value 업데이트를 따로 + 원하는 Tick 주기를 사용해서 구현 가능
- C++ BTService 종류의 Base 선택
- 아래 코드는 TickMode를 사용하여 Service 구현
```C++
void UBTService_PlayerLocationIfSeen::TickNode(UBehaviorTreeComponent &OwnerComp, uint8 *NodeMemory, float DeltaSeconds)
{
    Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds);

    APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);

    if (PlayerPawn == nullptr) return;
    if (OwnerComp.GetAIOwner() == nullptr) return;
    
    if (OwnerComp.GetAIOwner()->LineOfSightTo(PlayerPawn))
    {
        OwnerComp.GetBlackboardComponent()->SetValueAsVector(GetSelectedBlackboardKey(), PlayerPawn->GetActorLocation());
    }
    else
    {
        OwnerComp.GetBlackboardComponent()->ClearValue(GetSelectedBlackboardKey());
    }
}
```
- Service를 추가한 모습(초록색)
![[Pasted image 20240802172633.png]]

##### 193강
- 총이 자기 자신을 맞추는 문제 해결
```C++
//Gun.cpp | PullTrigger()
//구조체 생성
FCollisionQueryParams Params; 
//총 자기 자신과, 총을 들고있는 ACtor를 구조체에 추가
Params.AddIgnoredActor(this);
Params.AddIgnoredActor(GetOwner());
//LineTraceSingleByChannel의 마지막에 구조체를 추가해서 무시할 목록을 전달
bool bSuccess = GetWorld()->LineTraceSingleByChannel(Hit, Location, End, ECollisionChannel::ECC_GameTraceChannel1, Params);
```
- 사망 후 계속해서 사격 + Collision이 남아있는 문제 해결
```C++
//ShooterCharacter.cpp | TakeDamage()
if (IsDead())
{
	//더이상 컨트롤 불가
	DetachFromControllerPendingDestroy();
	//Collision 비활성화
	GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);
}
```

##### 194강
- 자체 GameMode 만든 후 다른 코드에서 해당 GameMode의 함수 호출하기
![[Pasted image 20240802174009.png]]
```C++
//ShooterCharacter.cpp | TakenDamage()
`#include "SimpleShooterGameModeBase.h"`
ASimpleShooterGameModeBase* GameMode = GetWorld()->GetAuthGameMode<ASimpleShooterGameModeBase>();
if (GameMode != nullptr)
{
    GameMode->PawnKilled(this);
}
```
